extern crate regex;
use regex::{Match, Regex};

pub use crate::modules::file::read_lines;

pub enum EachLanguageConfig {
    Python,
    Julia,
}

impl EachLanguageConfig {
    fn get_regex(&self) -> Vec<Regex> {
        match self {
            EachLanguageConfig::Python => vec![
                Regex::new(r"^import (?P<module>.+)").unwrap(),
                Regex::new(r"^from (?P<module>.+) import").unwrap(),
            ],
            EachLanguageConfig::Julia => vec![
                Regex::new(r"^using (?P<module>.+)").unwrap(),
                Regex::new(r"^import (?P<module>.+)").unwrap(),
            ],
        }
    }

    fn _get_extension(&self) -> String {
        match self {
            EachLanguageConfig::Python => String::from(".py"),
            EachLanguageConfig::Julia => String::from(".jl"),
        }
    }

    fn _get_default_modules(&self) -> Vec<&str> {
        match self {
            EachLanguageConfig::Python => vec![
                "__future__",
                "__main__",
                "_thread",
                "abc",
                "aifc",
                "and",
                "argparse",
                "array",
                "ast",
                "asynchat",
                "asyncio",
                "asyncore",
                "atexit",
                "audioop",
                "base64",
                "bdb",
                "binascii",
                "binhex",
                "bisect",
                "builtins",
                "bytearray",
                "bytes",
                "bz2",
                "calendar",
                "cgi",
                "cgitb",
                "chunk",
                "cmath",
                "cmd",
                "code",
                "codecs",
                "codeop",
                "collections",
                "colorsys",
                "compileall",
                "complex",
                "concurrent",
                "configparser",
                "contextlib",
                "contextvars",
                "copy",
                "copyreg",
                "crypt",
                "csv",
                "ctypes",
                "curses",
                "dataclasses",
                "datetime",
                "dbm",
                "decimal",
                "dict",
                "difflib",
                "dis",
                "distutils",
                "doctest",
                "email",
                "ensurepip",
                "enum",
                "errno",
                "faulthandler",
                "fcntl",
                "filecmp",
                "fileinput",
                "float",
                "fnmatch",
                "fractions",
                "frozenset",
                "ftplib",
                "functools",
                "gc",
                "getopt",
                "getpass",
                "gettext",
                "glob",
                "graphlib",
                "grp",
                "gzip",
                "hashlib",
                "heapq",
                "hmac",
                "html",
                "http",
                "imaplib",
                "imghdr",
                "imp",
                "import",
                "importlib",
                "inspect",
                "int",
                "io",
                "ioctl",
                "ipaddress",
                "itertools",
                "json",
                "keyword",
                "linecache",
                "list",
                "locale",
                "logging",
                "lzma",
                "mailbox",
                "mailcap",
                "marshal",
                "math",
                "memoryview",
                "mimetypes",
                "mmap",
                "modulefinder",
                "msilib",
                "msvcrt",
                "multiprocessing",
                "netrc",
                "nis",
                "nntplib",
                "not",
                "numbers",
                "operator",
                "optparse",
                "or",
                "os",
                "ossaudiodev",
                "pathlib",
                "pdb",
                "pickle",
                "pickletools",
                "pip",
                "pipes",
                "pkgutil",
                "platform",
                "plistlib",
                "poplib",
                "posix",
                "pprint",
                "pty",
                "pwd",
                "py_compile",
                "pyclbr",
                "pydoc",
                "queue",
                "quopri",
                "random",
                "range",
                "re",
                "readline",
                "repr()",
                "reprlib",
                "resource",
                "rlcompleter",
                "runpy",
                "sched",
                "secrets",
                "select",
                "selectors",
                "set",
                "shelve",
                "shlex",
                "shutil",
                "signal",
                "site",
                "smtpd",
                "smtplib",
                "sndhdr",
                "socket",
                "socketserver",
                "spwd",
                "sqlite3",
                "ssl",
                "stat",
                "stat()",
                "statistics",
                "str",
                "string",
                "stringprep",
                "struct",
                "subprocess",
                "sunau",
                "symtable",
                "sys",
                "sysconfig",
                "syslog",
                "tabnanny",
                "tarfile",
                "telnetlib",
                "tempfile",
                "termios",
                "test",
                "textwrap",
                "threading",
                "time",
                "timeit",
                "tkinter",
                "token",
                "tokenize",
                "trace",
                "traceback",
                "tracemalloc",
                "tty",
                "tuple",
                "turtle",
                "types",
                "typing",
                "unicodedata",
                "unittest",
                "urllib",
                "uu",
                "uuid",
                "venv",
                "warnings",
                "wave",
                "weakref",
                "webbrowser",
                "winreg",
                "winsound",
                "with",
                "wsgiref",
                "xdrlib",
                "xml",
                "xmlrpc",
                "zipapp",
                "zipfile",
                "zipimport",
                "zlib",
                "zoneinfo",
            ],
            EachLanguageConfig::Julia => vec![
                "Base",
                "Base64",
                "CRC32c",
                "Dates",
                "DelimitedFiles",
                "Distributed",
                "FileWatching",
                "Future",
                "InteractiveUtils",
                "LibGit2",
                "Libdl",
                "LinearAlgebra",
                "Logging",
                "Markdown",
                "Mmap",
                "Pkg",
                "Printf",
                "Profile",
                "Random",
                "SHA",
                "Serialization",
                "SharedArrays",
                "Sockets",
                "SparseArrays",
                "Statistics",
                "Test",
                "UUIDs",
                "Unicode",
            ],
        }
    }
}

pub trait ModuleExtractorComponents {
    fn extract(&mut self, source_code: Vec<String>) -> Vec<String>;
}

pub struct ModuleExtractor {
    pub language: EachLanguageConfig,
}

impl ModuleExtractorComponents for ModuleExtractor {
    fn extract(&mut self, splited_source_code: Vec<String>) -> Vec<String> {
        let mut result: Vec<String> = Vec::new();
        for line in splited_source_code {
            for regex in self.language.get_regex() {
                let captures: Vec<String> = regex
                    .captures(&line)
                    .unwrap()
                    .iter()
                    .map(|x: Option<Match>| x.unwrap().as_str().to_string())
                    .collect();
                result.push(captures[1].clone());
            }
        }
        result
    }
}
